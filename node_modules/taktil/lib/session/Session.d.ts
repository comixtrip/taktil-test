/// <reference types="typed-bitwig-api" />
import { EventEmitter } from './EventEmitter';
import { MidiOutProxy, MidiMessage, SysexMessage } from '../midi';
import { Control, ControlState } from '../control';
import { View } from '../view';
export interface Session extends EventEmitter {
    on(label: 'activateMode' | 'deactivateMode', callback: (mode: string) => void): void;
    on(label: 'activateView', callback: (view: typeof View) => void): void;
    on(label: 'init' | 'registerControls' | 'registerViews' | 'flush' | 'exit', callback: () => void): void;
    addListener(label: 'activateMode' | 'deactivateMode', callback: (mode: string) => void): void;
    addListener(label: 'activateView', callback: (view: typeof View) => void): void;
    addListener(label: 'init' | 'registerControls' | 'registerViews' | 'flush' | 'exit', callback: () => void): void;
    removeListener(label: 'activateMode' | 'deactivateMode', callback: (mode: string) => void): boolean;
    removeListener(label: 'activateView', callback: (view: typeof View) => void): boolean;
    removeListener(label: 'init' | 'registerControls' | 'registerViews' | 'flush' | 'exit', callback: () => void): boolean;
}
/**
 * A representation of the current project (or active Bitwig
 * Studio tab).
 *
 * Assists in managing shared state and session level event
 * subscriptions between Taktil and the control surface script.
 */
export declare class Session extends EventEmitter {
    private _isInit;
    private _controls;
    private _views;
    private _activeView;
    private _activeModes;
    private _eventHandlers;
    /** Global MidiOutProxy instance  */
    midiOut: MidiOutProxy;
    constructor();
    /** Check if bitwig is currently in it's init startup phase */
    readonly isInit: boolean;
    /** The midi in ports available to the session */
    readonly midiInPorts: API.MidiIn[];
    /** Handle midi input, routing it to the correct control object */
    onMidiInput(message: MidiMessage | SysexMessage): void;
    /**
     * Register controls to the session (can only be called once).
     *
     * @param controls The mapping of control labels to control instances to register
     * to the session.
     */
    registerControls(controls: {
        [label: string]: Control;
    }): void;
    /**
     * The mapping of control labels to control instances that have
     * been registered to the session.
     */
    readonly controls: {
        [x: string]: Control<ControlState>;
    };
    /** Find the control (if it exists) associated with an incoming Midi message. */
    findControl(message: MidiMessage | SysexMessage): Control | null;
    /**
     * Connect each registered control with its corresponding component (if any)
     * in the active view stack.
     *
     * This method is called internally anytime the active view or mode list
     * changes to re-associate controls to newly activated components.
     */
    associateControlsInView(): void;
    /** Force re-render all registered controls. */
    resetControls(): void;
    /**
     * Register views to the session (can only be called once).
     *
     * @param views The mapping of view labels to view classes to register
     * to the session.
     */
    registerViews(views: {
        [label: string]: typeof View;
    }): void;
    /**
     * The mapping of view labels to view classes that have been registered
     * to the session.
     */
    readonly views: {
        [x: string]: typeof View;
    };
    /** Set the active view of the session. */
    activateView(label: string): void;
    /** The active view of the session. */
    readonly activeView: typeof View;
    /** The list of active modes in the order they were activated, from last to first. */
    readonly activeModes: string[];
    /** Activate a mode, adding it to the active mode list. */
    activateMode(mode: string): void;
    /** Deactivate a given mode, removing it from the active mode list. */
    deactivateMode(mode: string): void;
    /** Check if a given mode is active. */
    modeIsActive(mode: string): boolean;
}
