import * as tslib_1 from "tslib";
import { EventEmitter } from './EventEmitter';
import { MidiOutProxy, MidiMessage, SysexMessage } from '../midi';
import { shim } from '../env';
/**
 * A representation of the current project (or active Bitwig
 * Studio tab).
 *
 * Assists in managing shared state and session level event
 * subscriptions between Taktil and the control surface script.
 */
var Session = /** @class */ (function (_super) {
    tslib_1.__extends(Session, _super);
    function Session() {
        var _this = _super.call(this) || this;
        _this._isInit = false;
        _this._controls = {};
        _this._views = {};
        _this._activeModes = [];
        _this._eventHandlers = {};
        /** Global MidiOutProxy instance  */
        _this.midiOut = new MidiOutProxy(_this);
        // shim bitwig scripting env, injecting session
        shim(_this);
        global.init = function () {
            _this._isInit = true;
            // call the session init callbacks
            _this.emit('init');
            // setup midi/sysex callbacks per port
            var midiInPorts = _this.midiInPorts;
            var _loop_1 = function (port) {
                midiInPorts[port].setMidiCallback(function (status, data1, data2) {
                    _this.onMidiInput(new MidiMessage({ port: port, status: status, data1: data1, data2: data2 }));
                });
                midiInPorts[port].setSysexCallback(function (data) {
                    _this.onMidiInput(new SysexMessage({ port: port, data: data }));
                });
            };
            for (var port = 0; port < midiInPorts.length; port += 1) {
                _loop_1(port);
            }
            _this._isInit = false;
        };
        global.flush = function () {
            _this.emit('flush');
        };
        global.exit = function () {
            // reset all controls to default state
            for (var controlName in _this.controls) {
                var control = _this.controls[controlName];
                control.setState(control.defaultState);
            }
            // call registered exit callbacks
            _this.emit('exit');
        };
        return _this;
    }
    Object.defineProperty(Session.prototype, "isInit", {
        /** Check if bitwig is currently in it's init startup phase */
        get: function () {
            return this._isInit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "midiInPorts", {
        // Midi
        //////////////////////////////
        /** The midi in ports available to the session */
        get: function () {
            var midiInPorts = [];
            for (var i = 0; true; i += 1) {
                try {
                    midiInPorts[i] = host.getMidiInPort(i);
                }
                catch (error) {
                    break;
                }
            }
            return midiInPorts;
        },
        enumerable: true,
        configurable: true
    });
    /** Handle midi input, routing it to the correct control object */
    Session.prototype.onMidiInput = function (message) {
        var control = this.findControl(message);
        var messageType = message instanceof MidiMessage ? '[MIDI] ' : '[SYSEX]';
        if (control)
            control.onMidiInput(message);
        console.log(messageType + " IN  " + message.port + " ==> " + (message instanceof MidiMessage
            ? message.shortHex
            : message.data) + (control && control.label ? " \"" + control.label + "\"" : ''));
    };
    // Controls
    //////////////////////////////
    /**
     * Register controls to the session (can only be called once).
     *
     * @param controls The mapping of control labels to control instances to register
     * to the session.
     */
    Session.prototype.registerControls = function (controls) {
        var _this = this;
        if (Object.keys(this.controls).length) {
            throw Error("The Session's registerControls method can only be called once.");
        }
        // assign view label to and inject session into each view
        Object.keys(controls).forEach(function (controlName) {
            controls[controlName].label = controlName;
            controls[controlName].session = _this;
        });
        var register = function () {
            var controlsArray = [];
            for (var controlName in controls) {
                var control = controls[controlName];
                // make sure patterns don't overlap
                for (var _i = 0, controlsArray_1 = controlsArray; _i < controlsArray_1.length; _i++) {
                    var existingControl = controlsArray_1[_i];
                    for (var _a = 0, _b = control.patterns; _a < _b.length; _a++) {
                        var pattern = _b[_a];
                        for (var _c = 0, _d = existingControl.patterns; _c < _d.length; _c++) {
                            var existingPattern = _d[_c];
                            if (pattern.conflictsWith(existingPattern)) {
                                throw new Error("Control \"" + control.label + "\" conflicts with existing Control \"" + existingControl.label + "\".");
                            }
                        }
                    }
                }
                // add to control array
                controlsArray.push(controls[controlName]);
            }
            _this._controls = controls;
            // emit registerControls event
            _this.emit('registerControls');
        };
        // if called during init register immediately
        if (this.isInit)
            return register();
        // otherwise defer until init
        this.on('init', register);
    };
    Object.defineProperty(Session.prototype, "controls", {
        /**
         * The mapping of control labels to control instances that have
         * been registered to the session.
         */
        get: function () {
            return tslib_1.__assign({}, this._controls);
        },
        enumerable: true,
        configurable: true
    });
    /** Find the control (if it exists) associated with an incoming Midi message. */
    Session.prototype.findControl = function (message) {
        // look for a matching registered control
        for (var controlName in this.controls) {
            var control = this.controls[controlName];
            for (var _i = 0, _a = control.patterns; _i < _a.length; _i++) {
                var pattern = _a[_i];
                // if pattern matches midiMessage, return control
                if (pattern.test(message))
                    return control;
            }
        }
        // not found, return null
        return null;
    };
    /**
     * Connect each registered control with its corresponding component (if any)
     * in the active view stack.
     *
     * This method is called internally anytime the active view or mode list
     * changes to re-associate controls to newly activated components.
     */
    Session.prototype.associateControlsInView = function () {
        // no view, no components to associate controls with
        if (!this.activeView)
            return;
        // connect each control to the corresponding component in view (if any)
        for (var controlName in this.controls) {
            var control = this.controls[controlName];
            this.activeView.connectControl(control);
        }
    };
    /** Force re-render all registered controls. */
    Session.prototype.resetControls = function () {
        for (var controlName in this.controls) {
            var control = this.controls[controlName];
            control.render(true);
        }
    };
    // Views
    //////////////////////////////
    /**
     * Register views to the session (can only be called once).
     *
     * @param views The mapping of view labels to view classes to register
     * to the session.
     */
    Session.prototype.registerViews = function (views) {
        var _this = this;
        if (Object.keys(this.views).length) {
            throw Error("The Session's registerViews method can only be called once.");
        }
        // assign view label to each view
        Object.keys(views).forEach(function (label) { return (views[label].label = label); });
        var register = function () {
            if (!Object.keys(_this.controls).length) {
                throw Error('Controls must be registered before views.');
            }
            var viewsToRegister = flattenViews(Object.keys(views).map(function (label) { return views[label]; }));
            var unvalidatedViews = viewsToRegister.slice();
            var attemptedValidations = [];
            var validatedViews = [];
            validation: while (true) {
                var view = unvalidatedViews.shift();
                if (!view)
                    break; // if we've run out of views to register we are done.
                for (var _i = 0, _a = view.extends; _i < _a.length; _i++) {
                    var ancestor = _a[_i];
                    // if the views parent has yet to be registered, push it to the end of the line
                    if (validatedViews.indexOf(ancestor) === -1) {
                        unvalidatedViews.push(view);
                        // catch circular dependency
                        if (attemptedValidations.indexOf(view) === -1) {
                            attemptedValidations.push(view);
                        }
                        else {
                            throw Error("Circular dependency detected in " + view.label + ".");
                        }
                        continue validation;
                    }
                }
                // everything looks good, register the view
                if (validatedViews.indexOf(view) === -1) {
                    // add to validate views list
                    validatedViews.push(view);
                    // initialize view
                    view.init(_this);
                }
                else {
                    throw Error("The same view class (" + view.label + ") cannot be registered more than once.");
                }
            }
            // with all views validated, set session views
            if (validatedViews.length === viewsToRegister.length) {
                _this._views = views;
                _this.emit('registerViews'); // emit registerViews event
            }
            else {
                throw Error('Unable to validate views for registration.');
            }
        };
        // if the controls have already been registered, register immediately
        if (Object.keys(this.controls).length)
            return register();
        // otherwise, defer until controls are registered
        this.on('registerControls', register);
    };
    Object.defineProperty(Session.prototype, "views", {
        /**
         * The mapping of view labels to view classes that have been registered
         * to the session.
         */
        get: function () {
            return tslib_1.__assign({}, this._views);
        },
        enumerable: true,
        configurable: true
    });
    /** Set the active view of the session. */
    Session.prototype.activateView = function (label) {
        var view = this.views[label];
        if (view === undefined)
            throw new Error("Cannot find view with label \"" + label + "\"");
        this._activeView = view;
        this.emit('activateView', view);
        this.associateControlsInView(); // re-associate controls in view
    };
    Object.defineProperty(Session.prototype, "activeView", {
        /** The active view of the session. */
        get: function () {
            return this._activeView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "activeModes", {
        // Modes
        //////////////////////////////
        /** The list of active modes in the order they were activated, from last to first. */
        get: function () {
            return this._activeModes.concat(['__BASE__']);
        },
        enumerable: true,
        configurable: true
    });
    /** Activate a mode, adding it to the active mode list. */
    Session.prototype.activateMode = function (mode) {
        if (mode === '__BASE__')
            throw new Error('Mode label "__BASE__" is reserved.');
        var modeIndex = this._activeModes.indexOf(mode);
        if (modeIndex > -1)
            this._activeModes.splice(modeIndex, 1);
        this._activeModes.unshift(mode); // prepend to modes
        this.emit('activateMode', mode);
        this.associateControlsInView(); // re-associate controls in view
    };
    /** Deactivate a given mode, removing it from the active mode list. */
    Session.prototype.deactivateMode = function (mode) {
        if (mode === '__BASE__')
            throw new Error('Mode label "__BASE__" is reserved.');
        var modeIndex = this._activeModes.indexOf(mode);
        if (modeIndex > -1) {
            this._activeModes.splice(modeIndex, 1);
            this.emit('deactivateMode', mode);
            this.associateControlsInView(); // re-associate controls in view
        }
    };
    /** Check if a given mode is active. */
    Session.prototype.modeIsActive = function (mode) {
        return this.activeModes.indexOf(mode) > -1;
    };
    return Session;
}(EventEmitter));
export { Session };
function flattenViews(views, distinct) {
    if (distinct === void 0) { distinct = true; }
    var flattenedViews = views
        .map(function (view) { return [view].concat(flattenViews(view.extends, false)); })
        .reduce(function (result, array) { return result.concat(array); }, []);
    if (!distinct)
        return flattenedViews;
    return flattenedViews.reduce(function (result, view) {
        if (result.indexOf(view) === -1)
            result.push(view);
        return result;
    }, []);
}
