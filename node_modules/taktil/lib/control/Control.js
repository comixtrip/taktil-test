import * as tslib_1 from "tslib";
import { MidiMessage, MessagePattern } from '../midi/';
/**
 * Abstract class defining the the base functionality from which all
 * other controls must extend.
 */
var Control = /** @class */ (function () {
    function Control(_a) {
        var patterns = _a.patterns, minValue = _a.minValue, maxValue = _a.maxValue, enableMidiOut = _a.enableMidiOut, enableCache = _a.enableCache, cacheOnMidiIn = _a.cacheOnMidiIn;
        var _this = this;
        this.minValue = 0;
        this.maxValue = 127;
        this.enableMidiOut = true;
        this.enableCache = true;
        this.cacheOnMidiIn = true;
        this.state = { value: 0 };
        this.cache = [];
        this._activeComponent = null;
        if (!patterns || patterns.length === 0)
            throw new Error("Error, Control must specify at least one pattern.");
        // set object properties
        this.patterns = patterns.map(function (pattern) { return (pattern instanceof MessagePattern ? pattern : new MessagePattern(pattern)); });
        if (minValue !== undefined)
            this.minValue = minValue;
        if (maxValue !== undefined)
            this.maxValue = maxValue;
        if (enableMidiOut !== undefined)
            this.enableMidiOut = enableMidiOut;
        if (enableCache !== undefined)
            this.enableCache = enableCache;
        if (cacheOnMidiIn !== undefined)
            this.cacheOnMidiIn = cacheOnMidiIn;
        // pull out shared pattern info into port, status, data1, and data2
        var isShared = this.patterns.reduce(function (result, p1, index) {
            // if there's just one pattern, return all true
            if (index === 0)
                return result;
            var p2 = _this.patterns[index - 1];
            if (result.port && p1.port !== p2.port)
                result.port = false;
            if (result.status && p1.status !== p2.status)
                result.status = false;
            if (result.data1 && p1.data1 !== p2.data1)
                result.data1 = false;
            if (result.data2 && p1.data2 !== p2.data2)
                result.data2 = false;
            return result;
        }, { port: true, status: true, data1: true, data2: true });
        var _b = this.patterns[0], port = _b.port, status = _b.status, data1 = _b.data1, data2 = _b.data2;
        if (isShared.port)
            this.port = port;
        if (isShared.status)
            this.status = status;
        if (isShared.data1)
            this.data1 = data1;
        if (isShared.data2)
            this.data2 = data2;
    }
    Object.defineProperty(Control.prototype, "valueRange", {
        get: function () {
            return this.maxValue - this.minValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Control.prototype, "defaultState", {
        // state
        get: function () {
            // if not set by setState, store initialized state value
            if (!this._defaultState)
                this._defaultState = JSON.parse(JSON.stringify(this.state));
            return this._defaultState;
        },
        enumerable: true,
        configurable: true
    });
    Control.prototype.setState = function (partialState, render) {
        if (render === void 0) { render = true; }
        this.defaultState; // make sure defaultState has been initialized
        if (partialState.value) {
            // validate value input
            if (partialState.value > this.maxValue || partialState.value < this.minValue) {
                throw new Error("Invalid value \"" + partialState.value + "\" for Control \"" + this
                    .label + "\" with value range " + this.minValue + " to " + this.maxValue + ".");
            }
        }
        // update state
        this.state = tslib_1.__assign({}, this.state, partialState); // TODO: should be able to remove type casting in future typescript release
        // re-render with new state
        if (render)
            this.render();
    };
    Object.defineProperty(Control.prototype, "activeComponent", {
        // active component
        get: function () {
            return this._activeComponent;
        },
        set: function (component) {
            // component not changing? do nothing
            if (component === this._activeComponent)
                return;
            // deactivate old component
            if (this._activeComponent && this._activeComponent.onDeactivate) {
                this._activeComponent.onDeactivate();
            }
            // activate new component
            this._activeComponent = component;
            if (this._activeComponent && this._activeComponent.onActivate) {
                this._activeComponent.onActivate();
            }
            // on component change, reset state to default
            this.setState(this.defaultState, false);
            // render new control state
            component ? component.render() : this.render();
        },
        enumerable: true,
        configurable: true
    });
    // midi i/o
    Control.prototype.getControlInput = function (message) {
        if (message instanceof MidiMessage &&
            message.status === this.status &&
            message.data1 === this.data1) {
            return tslib_1.__assign({}, this.state, { value: message.data2 }); // TODO: should be able to remove type casting in future typescript release
        }
        else {
            return this.state;
        }
    };
    Control.prototype.cacheMidiMessage = function (midiMessage) {
        if (this.cache.indexOf(midiMessage.hex) !== -1)
            return false;
        for (var i = 0; i < this.patterns.length; i += 1) {
            var pattern = this.patterns[i];
            if (pattern.test(midiMessage)) {
                this.cache[i] = midiMessage.hex;
                return true;
            }
        }
        // no match
        throw new Error("MidiMessage \"" + midiMessage.hex + "\" does not match existing pattern on Control \"" + this
            .label + "\".");
    };
    Control.prototype.onMidiInput = function (message) {
        // update cache with input
        if (this.cacheOnMidiIn && message instanceof MidiMessage)
            this.cacheMidiMessage(message);
        if (this.activeComponent) {
            this.activeComponent.onControlInput(this.getControlInput(message));
            this.render(); // make sure hardware reflects control state
        }
        else {
            // re-render based on current state (messages will only be sent if they are
            // different than what's in the cache)
            this.render();
            console.info("Control \"" + this.label + "\" is not mapped in the active view stack.");
        }
    };
    Control.prototype.getMidiOutput = function (state) {
        var _a = this, port = _a.port, status = _a.status, data1 = _a.data1, data2 = _a.data2;
        if (port !== undefined && status !== undefined && data1 !== undefined) {
            // if it's a simple midi control (port,status, and data1 provided), handle it
            return !data2 ? [new MidiMessage({ port: port, status: status, data1: data1, data2: state.value })] : [];
        }
        else {
            // otherwise leave it up to the implementation
            return [];
        }
    };
    Control.prototype.render = function (force) {
        var _this = this;
        if (force === void 0) { force = !this.enableCache; }
        // no midi out? no render.
        if (!this.enableMidiOut)
            return false;
        // get list of messages that will be sent
        var messages = this.getMidiOutput(this.state).filter(function (message) {
            if (message instanceof MidiMessage) {
                // send midi message to cache, add to message list if new
                return _this.cacheMidiMessage(message) || force;
            }
            else {
                // sysex messages are not cached, always send
                return true;
            }
        });
        // call pre render hook only if something will be rendered
        if (messages.length && this.controlWillRender)
            this.controlWillRender(messages);
        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
            var message = messages_1[_i];
            if (message instanceof MidiMessage) {
                // send midi message
                var port = message.port, status_1 = message.status, data1 = message.data1, data2 = message.data2, urgent = message.urgent;
                this.session.midiOut.sendMidi({
                    port: port,
                    status: status_1,
                    data1: data1,
                    data2: data2,
                    urgent: urgent,
                    label: this.label,
                });
            }
            else {
                // send sysex message
                var port = message.port, data = message.data;
                this.session.midiOut.sendSysex({ port: port, data: data });
            }
        }
        // call post render hook
        if (this.controlDidRender)
            this.controlDidRender(messages);
        return true;
    };
    return Control;
}());
export { Control };
