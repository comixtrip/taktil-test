import * as tslib_1 from "tslib";
import { Control } from './Control';
import { MidiMessage } from '../midi';
var Note = /** @class */ (function (_super) {
    tslib_1.__extends(Note, _super);
    function Note(_a) {
        var _b = _a.port, port = _b === void 0 ? 0 : _b, channel = _a.channel, key = _a.key, rest = tslib_1.__rest(_a, ["port", "channel", "key"]);
        var _this = _super.call(this, tslib_1.__assign({ patterns: [
                { port: port, status: 0x90 | channel, data1: key },
                { port: port, status: 0x80 | channel, data1: key },
            ] }, rest)) || this;
        _this.useNoteOff = false;
        _this.channel = channel;
        return _this;
    }
    Note.prototype.getControlInput = function (message) {
        if (message.isNoteOff && !this.useNoteOff)
            this.useNoteOff = true;
        return tslib_1.__assign({}, this.state, { value: message.isNoteOn ? message.data2 : 0 }); // TODO: should be able to remove type casting in future typescript release
    };
    Note.prototype.getMidiOutput = function (_a) {
        var value = _a.value;
        var _b = this, port = _b.port, channel = _b.channel, data1 = _b.data1;
        if (this.useNoteOff && value === 0) {
            return [new MidiMessage({ port: port, data1: data1, status: 0x80 | channel, data2: value })];
        }
        else {
            return [new MidiMessage({ port: port, data1: data1, status: 0x90 | channel, data2: value })];
        }
    };
    return Note;
}(Control));
export { Note };
